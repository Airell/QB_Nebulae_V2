nebconfigbegin
ksmps,128
-B,2048
-b,128
size_alt,0.5
pitch_alt,0.5
reset,triggered,rising
file,incremental,falling
sr,48000
nebconfigend

/****************
 AVALON - "Morphing Nebulaeum" v1.2, 27-10-2021, inspired by the Morphing Terrarium E350 and the loading of samples from the Cloud Terrarium E352

 * Overview of controls *
 * Pitch        - Coarse tune     [gkpitch]
 * Pitch Alt    - Fine tune       [gkpitch_alt]     ; If necessary...
 * Speed        - Z course        [gkspeed]         ; Best candidate for Z. It has a higher resolution than other knobs
 * Start        - X               [gkloopstart]
 * Start Alt    - ---             [gkloopstart_alt]
 * Size         - Z fine          [gkloopsize]
 * Size Alt     - Z fine range    [gkloopsize_alt]  ; range of -/+ 1,2,4,6 or 8 samples
 * Density      - Y               [gkdensity]
 * Density Alt  - ---             [gkdensity_alt]
 * Overlap      - ---             [gkoverlap]
 * Overlap Alt  - ---             [gkoverlap_alt]
 * Blend        - XY-Z morph      [gkblend]
 * Blend Alt    - XY-Z morph mode [gkblend_alt]     ; range from 1 to 5 (CCW, 9-10, 12, 14-15, CW)
 * Window       - ---             [gkwindow]
 * Window Alt   - ---             [gkwindow_alt]
 * Record       - ---             [gkrecord]
 * File         - Next bank       [gkfilesel]
 * Source       - ---             [gksource]
 * Reset        - Reset to bank 1 [gkreset]         ; or advance 5 banks of consecutive Reset presses
 * Freeze       - ---             [gkfreeze]

 Issues / Fixed / Rework / Enhancement
 #1 : Pressing Reset will return to bank 1 (first bank). Consecutive presses will advance 5 banks. Added in v1.1
 #2 : Code optimization, no functional changes. v1.2
 #3 : Complete rewrite of morphing technique and oscillator type, to eliminate pitch artefacts. v1.3

****************/

instr 1

; === INITIALIZATION
; =========================

kInit init 1
if kInit == 1 then
  ; Do things at init time
  ; The function 'init' can be used in statements, but this is evaluated every cycle. Now only 1 'init' needs to be evaluated

  ; Number of waves in a XY-row or Z-bank
  knumwavesX = 8
  knumwavesY = 8
  knumwavesZ = 64

  ; empty tables
  iTabY1 ftgen 600, 0, 256, -2, 0
  iTabY2 ftgen 601, 0, 256, -2, 0
  iTabY3 ftgen 602, 0, 256, -2, 0
  iTabY4 ftgen 603, 0, 256, -2, 0
  iTabY5 ftgen 604, 0, 256, -2, 0
  iTabY6 ftgen 605, 0, 256, -2, 0
  iTabY7 ftgen 606, 0, 256, -2, 0
  iTabY8 ftgen 607, 0, 256, -2, 0
  iTabXY ftgen 608, 0, 768, -2, 0
  iTabZ  ftgen 609, 0, 768, -2, 0

  ; Nebulae V2 loaded files will start at table 400, 399 + 'gkfilesel' starts at 400.
  kBank = 400
  gkfilesel_offset = 399

  ; On every 'File press', 'gkfilesel' is set to the internal 'Current file index'.
  ; This means when 'gkfilesel' would manually be reset to '0' and 'File' is being pressed, it does not advance to '1', but to 'Current file index + 1'.
  ; We need to make our own 'Press File' and 'Selected File' meganism
  kfilesel = gkfilesel  ; Store the 'saved' (last selected) wavetable bank
  gkfilesel_old = gkfilesel
  if kfilesel = 0 then
    kreset = 1
  endif

  ; Defince C in Hz
  kC4 = 261.625565
  kC3 = kC4 / 2
  kC2 = kC4 / 4
  kBaseC = kC3

  ; Amplitude can by (too) hight sometimes, make it 0.8
  kAmp = 0.8

  ; 'init' is over
  kInit = 0
endif


; BANK SELECT
; =========================

; Detect Reset
kresettrig trigger gkreset, 0.5, 0

; Detect File press, does not work 100% with a trigger
if gkfilesel_old != gkfilesel then
  gkfilesel_old = gkfilesel
  kreset = 0
  kfilesel = kfilesel + 1
endif

if kresettrig == 1 then
  if kreset = 0 then
    ; when reset is pressed after a File press (reset = 0), reset to wavetable bank 0
    kfilesel = 0
    kreset = 1
  else
    ; when reset is pressed directly after reset (reset = 1), advance 5 wavetables banks
    kfilesel = kfilesel + 5
  endif
endif

; If we would advance further than the number of loaded waveform banks, reset to 0
if kfilesel > ginumfiles - 1 then
  kreset = 1
  kfilesel = 0
endif

; gkfilesel - index of table containing audio file data. 'gkfilesel' is updated (and rotated) on 'File' press.
kBank = gkfilesel_offset + kfilesel + 1


; PITCH FACTOR
; =========================

kpitch_scale scale gkpitch, 2, -3
kpitch_fine = kpitch_scale * (1 + ((gkpitch_alt - 0.5) / 10))

kpitch pow 2, kpitch_fine
kpitch_factor = kpitch * (kBaseC / ( sr / 256 ))  ;  Compensate for pitch, to have 0v = C3 = 130.8128 Hz


; === MORPHING
; =========================

; Y Morphing
kPosY portk (gkloopstart * (knumwavesY - 1)), 0.02

kIndexY = int(kPosY)

kIndexY1 = round((kIndexY / 2) + 0.000001) * 2
kIndexY1 = (kIndexY1 > (knumwavesY - 1) ? 0 : kIndexY1)
kIndexY2 = (round(((kIndexY + 1) / 2) + 0.000001) * 2) - 1

kVolY2 = ((kPosY % 2) < 1 ? (kPosY % 2) : 1 - ((kPosY % 2) - 1))
kVolY1 = 1 - kVolY2

;;  -- samples starting points, length 256 each
;;  7 14336 14592 14848 15104 15360 15616 15872 16128
;;  6 12288 12544 12800 13056 13312 13568 13824 14080
;;  5 10240 10496 10752 11008 11264 11520 11776 12032
;;  4  8192  8448  8704  8960  9216  9472  9728  9984
;;  3  6144  6400  6656  6912  7168  7424  7680  7936
;;  2  4096  4352  4608  4864  5120  5376  5632  5888
;;  1  2048  2304  2560  2816  3072  3328  3584  3840
;;  0     0   256   512   768  1024  1280  1536  1792
;;  Y X > 0     1     2     3     4     5     6     7

; 8 tables, 1 for each 'Y-row'
; tablemix DEST_TABLE, START_INDEX, #POINTS_TO_COPY
tablemix iTabY1, 0, 256, kBank, (kIndexY1 * 256) + 00000, kVolY1, kBank, ((kIndexY2) * 256) + 00000, kVolY2
tablemix iTabY2, 0, 256, kBank, (kIndexY1 * 256) + 02048, kVolY1, kBank, ((kIndexY2) * 256) + 02048, kVolY2
tablemix iTabY3, 0, 256, kBank, (kIndexY1 * 256) + 04096, kVolY1, kBank, ((kIndexY2) * 256) + 04096, kVolY2
tablemix iTabY4, 0, 256, kBank, (kIndexY1 * 256) + 06144, kVolY1, kBank, ((kIndexY2) * 256) + 06144, kVolY2
tablemix iTabY5, 0, 256, kBank, (kIndexY1 * 256) + 08192, kVolY1, kBank, ((kIndexY2) * 256) + 08192, kVolY2
tablemix iTabY6, 0, 256, kBank, (kIndexY1 * 256) + 10240, kVolY1, kBank, ((kIndexY2) * 256) + 10240, kVolY2
tablemix iTabY7, 0, 256, kBank, (kIndexY1 * 256) + 12288, kVolY1, kBank, ((kIndexY2) * 256) + 12288, kVolY2
tablemix iTabY8, 0, 256, kBank, (kIndexY1 * 256) + 14336, kVolY1, kBank, ((kIndexY2) * 256) + 14336, kVolY2


; X Morphing
; =========================

kPosX portk (gkdensity * (knumwavesY - 1)), 0.02

kIndexX = int(kPosX)

kIndexX1 = round((kIndexX / 2) + 0.000001) * 2
kIndexX1 = (kIndexX1 > (knumwavesX - 1) ? 0 : kIndexX1)
kIndexX2 = (round(((kIndexX + 1) / 2) + 0.000001) * 2) - 1

kVolX2 = ((kPosX % 2) < 1 ? (kPosX % 2) : 1 - ((kPosX % 2) - 1))
kVolX1 = 1 - kVolX2

; now mix the right 'Y-row' into XY
; The linear interpolation needs preceding and appending waveforms, to overcome artifacts when the does not start 'at zero'.
; The most easiest process is to add the same wave before and after the wave that will be played.
tablemix iTabXY, 000, 256, 600 + kIndexX1, 0, kVolX1, 600 + kIndexX2, 0, kVolX2
tablemix iTabXY, 256, 256, 600 + kIndexX1, 0, kVolX1, 600 + kIndexX2, 0, kVolX2
tablemix iTabXY, 512, 256, 600 + kIndexX1, 0, kVolX1, 600 + kIndexX2, 0, kVolX2


; Z Morphing
; =========================

; -- set the Z position fine range
kPosZfineRange_select scale gkloopsize_alt, 5, 1
kPosZfineRange_select = round(kPosZfineRange_select)

if     kPosZfineRange_select = 1 then ;; Fully CCW
  kPosZfineRange = 1
elseif kPosZfineRange_select = 2 then
  kPosZfineRange = 2
elseif kPosZfineRange_select = 3 then
  kPosZfineRange = 4  ; 'half a row width'
elseif kPosZfineRange_select = 4 then
  kPosZfineRange = 6
elseif kPosZfineRange_select = 5 then ;; Fully CW
  kPosZfineRange = 8  ; 'one row width'
endif

kPosZfine = ((gkloopsize * kPosZfineRange) - (kPosZfineRange / 2))
kPosZ portk (gkspeed * (knumwavesZ - 1) + kPosZfine), 0.02
kPosZ limit kPosZ, 0, (knumwavesZ - 1)

kIndexZ = int(kPosZ)

kIndexZ1 = round((kIndexZ / 2) + 0.000001) * 2
kIndexZ1 = (kIndexZ1 > 63 ? 0 : kIndexZ1)
kIndexZ2 = (round(((kIndexZ + 1) / 2) + 0.000001) * 2) - 1

kvolZ2 = (((kPosZ % 2)) < 1 ? ((kPosZ % 2)) : 1 - (((kPosZ % 2)) - 1))
kvolZ1 = 1 - kvolZ2

;printks2 "kvolZ1 %f\n", kvolZ1
;printks2 "kvolZ2 %f\n", kvolZ2

; The linear interpolation needs preceding and appending waveforms, to overcome artifacts when the does not start 'at zero'.
; The most easiest process is to add the same wave before and after the wave that will be played.
tablemix iTabZ, 000, 256, kBank, (kIndexZ1 * 256), kvolZ1, kBank, (kIndexZ2 * 256), kvolZ2
tablemix iTabZ, 256, 256, kBank, (kIndexZ1 * 256), kvolZ1, kBank, (kIndexZ2 * 256), kvolZ2
tablemix iTabZ, 512, 256, kBank, (kIndexZ1 * 256), kvolZ1, kBank, (kIndexZ2 * 256), kvolZ2

kwindow scale gkwindow, 2, 1
kOscType = round(kwindow)
printks2 "kOscType %f\n", kOscType

if kOscType = 1 then
  asigZ  lposcil kAmp, kpitch_factor, 256, 512, iTabZ
  asigXY lposcil kAmp, kpitch_factor, 256, 512, iTabXY
elseif kOscType = 2 then
  ; alternative 'cubic interpolation' oscillator
  asigZ  lposcil3 kAmp, kpitch_factor, 256, 512, iTabZ
  asigXY lposcil3 kAmp, kpitch_factor, 256, 512, iTabXY
endif

; earlier oscillator types, but has artifacts
;  asigZ oscil kAmp, kBaseC * kpitch, iTabZ
;  asigZ poscil kAmp, kBaseC * kpitch, iTabZ, 1
;  asigZ oscili kAmp, kBaseC * kpitch, iTabZ
;  asigZ oscil3 kAmp, kBaseC * kpitch, iTabZ


; MORPH MODES
; =========================

kblend_alt scale gkblend_alt, 5, 1
kXYZMorphMode = round(kblend_alt)

;printks2 "kXYZMorphMode %f\n", kXYZMorphMode

; kXYZMorphMode = 1 CCW ;; R channel (Z):  Morph L=XY into R=Z  (middle result, R=XYZ) and then 'unmorph' (end result, R=XY). L channel (XY) is unchanged.
; kXYZMorphMode = 2     ;; L channel (XY): Morph R=Z  into L=XY (middle result, L=XYZ) and then 'unmorph' (end result, L=Z).  R channel (Z)  is unchanged.
; kXYZMorphMode = 3 CEN ;; Morph L=XY into R=Z and R=Z into L=XY (end result, R=XYZ and L=XYZ)
; kXYZMorphMode = 4     ;; Morph L=XY, R=XY into R=Z, L=Z in the middle (middle result, R=XYZ and L=XYZ) and then 'unmorph' (end result, R=Z and L=Z)
; kXYZMorphMode = 5 CW  ;; Morph L=XY into R=Z and R=Z into L=XY in the middle (middle result, R=XYZ and L=XYZ) and then 'unmorph' (end result is swapped, R=Z and L=XY)

kblend portk gkblend, 0.01
kBlend_factor scale kblend, 0.8, 1

if kXYZMorphMode = 1 then
  aoutL = asigXY
;  aoutR = (asigZ + (asigXY * kblend)) * kBlend_factor  ;   CW = XYZ
  aoutR = ((asigZ * (1-kblend)) + (asigXY * kblend))
elseif kXYZMorphMode = 2 then
;  aoutL = (asigXY + (asigZ * kblend)) * kBlend_factor  ;   CW = XYZ
  aoutL = ((asigXY * (1-kblend)) + (asigZ * kblend))
  aoutR = asigZ
elseif kXYZMorphMode = 3 then
  aoutL = (asigXY + (asigZ * kblend)) * kBlend_factor
  aoutR = (asigZ + (asigXY * kblend)) * kBlend_factor
elseif kXYZMorphMode = 4 then
  aoutL = ((asigXY * (1-kblend)) + (asigZ * kblend))
  aoutR = ((asigXY * (1-kblend)) + (asigZ * kblend))
else ;; kXYZMorphMode = 5
  aoutL = ((asigXY * (1-kblend)) + (asigZ * kblend))
  aoutR = ((asigZ * (1-kblend)) + (asigXY * kblend))
endif

outs aoutL, aoutR

endin
